//! Key management for Stand encryption.
//!
//! Handles generation, saving, and loading of age X25519 key pairs.

use std::fs;
use std::io::Write;
use std::path::Path;

use age::secrecy::ExposeSecret;
use age::x25519::{Identity, Recipient};

use super::CryptoError;

/// A key pair consisting of a public key (for encryption) and a private key (for decryption).
#[derive(Debug, Clone)]
pub struct KeyPair {
    /// The public key string (age1...)
    pub public_key: String,
    /// The private key string (AGE-SECRET-KEY-1...)
    pub private_key: String,
}

impl KeyPair {
    /// Creates a new KeyPair from existing key strings.
    pub fn new(public_key: String, private_key: String) -> Self {
        Self {
            public_key,
            private_key,
        }
    }

    /// Parses the public key into an age Recipient.
    pub fn to_recipient(&self) -> Result<Recipient, CryptoError> {
        self.public_key
            .parse::<Recipient>()
            .map_err(|e| CryptoError::InvalidPublicKey(e.to_string()))
    }

    /// Parses the private key into an age Identity.
    pub fn to_identity(&self) -> Result<Identity, CryptoError> {
        self.private_key
            .parse::<Identity>()
            .map_err(|e| CryptoError::InvalidPrivateKey(e.to_string()))
    }
}

/// Generates a new X25519 key pair.
pub fn generate_key_pair() -> KeyPair {
    let identity = Identity::generate();
    let recipient = identity.to_public();

    KeyPair {
        public_key: recipient.to_string(),
        private_key: identity.to_string().expose_secret().to_string(),
    }
}

/// Saves the private key to a file.
///
/// The file is created with restricted permissions (0600 on Unix).
pub fn save_private_key(path: &Path, private_key: &str) -> Result<(), CryptoError> {
    let content = format!(
        "# Stand encryption keys - DO NOT COMMIT TO VERSION CONTROL\n\
         # Generated by: stand encrypt enable\n\
         \n\
         STAND_PRIVATE_KEY={}\n",
        private_key
    );

    let mut file = fs::File::create(path)?;
    file.write_all(content.as_bytes())?;

    // Set file permissions to 0600 on Unix
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = fs::Permissions::from_mode(0o600);
        fs::set_permissions(path, permissions)?;
    }

    Ok(())
}

/// Loads the private key from a file.
pub fn load_private_key(path: &Path) -> Result<String, CryptoError> {
    let content = fs::read_to_string(path)?;

    for line in content.lines() {
        let line = line.trim();
        if line.starts_with("STAND_PRIVATE_KEY=") {
            return Ok(line.strip_prefix("STAND_PRIVATE_KEY=").unwrap().to_string());
        }
    }

    Err(CryptoError::NoPrivateKey)
}

/// Loads the private key from an environment variable.
pub fn load_private_key_from_env() -> Option<String> {
    std::env::var("STAND_PRIVATE_KEY").ok()
}

/// Parses a public key string into an age Recipient.
pub fn parse_public_key(public_key: &str) -> Result<Recipient, CryptoError> {
    public_key
        .parse::<Recipient>()
        .map_err(|e| CryptoError::InvalidPublicKey(e.to_string()))
}

/// Parses a private key string into an age Identity.
pub fn parse_private_key(private_key: &str) -> Result<Identity, CryptoError> {
    private_key
        .parse::<Identity>()
        .map_err(|e| CryptoError::InvalidPrivateKey(e.to_string()))
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use tempfile::tempdir;

    #[test]
    fn test_generate_key_pair() {
        let key_pair = generate_key_pair();

        // Public key should start with "age1"
        assert!(
            key_pair.public_key.starts_with("age1"),
            "Public key should start with 'age1', got: {}",
            key_pair.public_key
        );

        // Private key should start with "AGE-SECRET-KEY-1"
        assert!(
            key_pair.private_key.starts_with("AGE-SECRET-KEY-1"),
            "Private key should start with 'AGE-SECRET-KEY-1', got: {}",
            key_pair.private_key
        );
    }

    #[test]
    fn test_key_pair_to_recipient_and_identity() {
        let key_pair = generate_key_pair();

        // Should be able to parse back to age types
        assert!(key_pair.to_recipient().is_ok());
        assert!(key_pair.to_identity().is_ok());
    }

    #[test]
    fn test_save_and_load_private_key() {
        let dir = tempdir().unwrap();
        let key_file = dir.path().join(".stand.keys");

        let key_pair = generate_key_pair();
        save_private_key(&key_file, &key_pair.private_key).unwrap();

        let loaded = load_private_key(&key_file).unwrap();
        assert_eq!(loaded, key_pair.private_key);
    }

    #[test]
    fn test_load_private_key_missing_file() {
        let result = load_private_key(Path::new("/nonexistent/.stand.keys"));
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_invalid_public_key() {
        let result = parse_public_key("invalid-key");
        assert!(result.is_err());
        assert!(matches!(result, Err(CryptoError::InvalidPublicKey(_))));
    }

    #[test]
    fn test_parse_invalid_private_key() {
        let result = parse_private_key("invalid-key");
        assert!(result.is_err());
        assert!(matches!(result, Err(CryptoError::InvalidPrivateKey(_))));
    }

    #[test]
    #[serial]
    fn test_load_private_key_from_env() {
        let key_pair = generate_key_pair();
        std::env::set_var("STAND_PRIVATE_KEY", &key_pair.private_key);

        let result = load_private_key_from_env();
        assert_eq!(result, Some(key_pair.private_key));

        std::env::remove_var("STAND_PRIVATE_KEY");
    }

    #[test]
    #[serial]
    fn test_load_private_key_from_env_not_set() {
        std::env::remove_var("STAND_PRIVATE_KEY");

        let result = load_private_key_from_env();
        assert!(result.is_none());
    }

    #[test]
    #[cfg(unix)]
    fn test_save_private_key_sets_secure_permissions() {
        use std::os::unix::fs::PermissionsExt;

        let dir = tempdir().unwrap();
        let key_file = dir.path().join(".stand.keys");
        let key_pair = generate_key_pair();

        save_private_key(&key_file, &key_pair.private_key).unwrap();

        let metadata = std::fs::metadata(&key_file).unwrap();
        let mode = metadata.permissions().mode() & 0o777;
        assert_eq!(mode, 0o600, "File should have 0600 permissions");
    }
}
