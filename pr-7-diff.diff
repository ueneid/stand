diff --git a/src/error/mod.rs b/src/error/mod.rs
index cd40856..4cc769d 100644
--- a/src/error/mod.rs
+++ b/src/error/mod.rs
@@ -1 +1,3 @@
 pub mod types;
+
+pub use types::CliError;
diff --git a/src/error/types.rs b/src/error/types.rs
index 76e3ddc..b62380f 100644
--- a/src/error/types.rs
+++ b/src/error/types.rs
@@ -1 +1,155 @@
-// types.rs module
+use thiserror::Error;
+
+/// CLI-specific errors for user-facing messages
+#[derive(Error, Debug)]
+pub enum CliError {
+    #[error("Stand project not initialized. Run 'stand init' to get started.")]
+    ProjectNotInitialized,
+
+    #[error("Environment '{name}' not found in configuration.")]
+    EnvironmentNotFound { name: String },
+
+    #[error("Configuration file not found. Run 'stand init' to create one.")]
+    ConfigurationNotFound,
+
+    #[error("Configuration validation failed: {reason}")]
+    ConfigurationInvalid { reason: String },
+
+    #[error("Stand is already initialized in this directory.")]
+    AlreadyInitialized,
+
+    #[error("Cannot write to file '{path}': {reason}")]
+    FileWriteError { path: String, reason: String },
+
+    #[error("Cannot read file '{path}': {reason}")]
+    FileReadError { path: String, reason: String },
+
+    #[error("Invalid environment name '{name}'. Names must be alphanumeric and may contain hyphens or underscores.")]
+    InvalidEnvironmentName { name: String },
+}
+
+impl CliError {
+    /// Convert a configuration error to a CLI error with user-friendly message
+    pub fn from_config_error(err: crate::config::ConfigError) -> Self {
+        match err {
+            crate::config::ConfigError::ValidationError { message } => {
+                Self::ConfigurationInvalid { reason: message }
+            }
+            crate::config::ConfigError::InvalidEnvironment { name } => {
+                Self::EnvironmentNotFound { name }
+            }
+            _ => Self::ConfigurationInvalid {
+                reason: err.to_string(),
+            },
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_project_not_initialized_error() {
+        let error = CliError::ProjectNotInitialized;
+        let message = error.to_string();
+        assert!(message.contains("Stand project not initialized"));
+        assert!(message.contains("'stand init'"));
+    }
+
+    #[test]
+    fn test_environment_not_found_error() {
+        let error = CliError::EnvironmentNotFound {
+            name: "nonexistent".to_string(),
+        };
+        let message = error.to_string();
+        assert!(message.contains("Environment 'nonexistent' not found"));
+    }
+
+    #[test]
+    fn test_configuration_not_found_error() {
+        let error = CliError::ConfigurationNotFound;
+        let message = error.to_string();
+        assert!(message.contains("Configuration file not found"));
+        assert!(message.contains("'stand init'"));
+    }
+
+    #[test]
+    fn test_configuration_invalid_error() {
+        let error = CliError::ConfigurationInvalid {
+            reason: "missing version field".to_string(),
+        };
+        let message = error.to_string();
+        assert!(message.contains("Configuration validation failed"));
+        assert!(message.contains("missing version field"));
+    }
+
+    #[test]
+    fn test_already_initialized_error() {
+        let error = CliError::AlreadyInitialized;
+        let message = error.to_string();
+        assert!(message.contains("already initialized"));
+    }
+
+    #[test]
+    fn test_file_write_error() {
+        let error = CliError::FileWriteError {
+            path: "/some/path/.stand.toml".to_string(),
+            reason: "permission denied".to_string(),
+        };
+        let message = error.to_string();
+        assert!(message.contains("Cannot write to file '/some/path/.stand.toml'"));
+        assert!(message.contains("permission denied"));
+    }
+
+    #[test]
+    fn test_file_read_error() {
+        let error = CliError::FileReadError {
+            path: "/some/path/.stand.toml".to_string(),
+            reason: "file not found".to_string(),
+        };
+        let message = error.to_string();
+        assert!(message.contains("Cannot read file '/some/path/.stand.toml'"));
+        assert!(message.contains("file not found"));
+    }
+
+    #[test]
+    fn test_invalid_environment_name_error() {
+        let error = CliError::InvalidEnvironmentName {
+            name: "invalid@name".to_string(),
+        };
+        let message = error.to_string();
+        assert!(message.contains("Invalid environment name 'invalid@name'"));
+        assert!(message.contains("alphanumeric"));
+    }
+
+    #[test]
+    fn test_from_config_error_validation() {
+        let config_err = crate::config::ConfigError::ValidationError {
+            message: "test validation error".to_string(),
+        };
+        let cli_err = CliError::from_config_error(config_err);
+
+        match cli_err {
+            CliError::ConfigurationInvalid { reason } => {
+                assert_eq!(reason, "test validation error");
+            }
+            _ => panic!("Expected ConfigurationInvalid error"),
+        }
+    }
+
+    #[test]
+    fn test_from_config_error_invalid_environment() {
+        let config_err = crate::config::ConfigError::InvalidEnvironment {
+            name: "test-env".to_string(),
+        };
+        let cli_err = CliError::from_config_error(config_err);
+
+        match cli_err {
+            CliError::EnvironmentNotFound { name } => {
+                assert_eq!(name, "test-env");
+            }
+            _ => panic!("Expected EnvironmentNotFound error"),
+        }
+    }
+}
diff --git a/src/utils/colors.rs b/src/utils/colors.rs
index 939c4df..1cc29c3 100644
--- a/src/utils/colors.rs
+++ b/src/utils/colors.rs
@@ -1 +1,97 @@
-// colors.rs module
+use colored::Colorize;
+
+/// Colorize an environment name with the specified color
+pub fn colorize_environment(env_name: &str, color: Option<&str>) -> String {
+    match color {
+        Some("red") => env_name.red().to_string(),
+        Some("green") => env_name.green().to_string(),
+        Some("blue") => env_name.blue().to_string(),
+        Some("yellow") => env_name.yellow().to_string(),
+        Some("purple") => env_name.purple().to_string(),
+        Some("cyan") => env_name.cyan().to_string(),
+        _ => env_name.to_string(), // Invalid colors or None fallback to plain text
+    }
+}
+
+/// Format the default marker for environment listing
+pub fn format_default_marker(is_default: bool) -> &'static str {
+    if is_default {
+        "*"
+    } else {
+        " "
+    }
+}
+
+/// Mask sensitive values for display
+pub fn mask_value(value: &str, show_values: bool) -> String {
+    if show_values || value.is_empty() {
+        value.to_string()
+    } else {
+        "********".to_string()
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_colorize_environment_with_green() {
+        let result = colorize_environment("dev", Some("green"));
+        // The function should return colored text (may not contain ANSI codes in test env)
+        // but should at least contain the original text
+        assert!(result.contains("dev"));
+        // In test environment, colored crate may or may not add ANSI codes
+        // The important thing is that the function handles green color without panicking
+    }
+
+    #[test]
+    fn test_colorize_environment_with_red() {
+        let result = colorize_environment("prod", Some("red"));
+        // Same logic as green test
+        assert!(result.contains("prod"));
+    }
+
+    #[test]
+    fn test_colorize_environment_with_invalid_color() {
+        let result = colorize_environment("test", Some("invalid"));
+        // Should fallback to no color
+        assert_eq!(result, "test");
+    }
+
+    #[test]
+    fn test_colorize_environment_with_no_color() {
+        let result = colorize_environment("staging", None);
+        assert_eq!(result, "staging");
+    }
+
+    #[test]
+    fn test_format_default_marker_true() {
+        let result = format_default_marker(true);
+        assert_eq!(result, "*");
+    }
+
+    #[test]
+    fn test_format_default_marker_false() {
+        let result = format_default_marker(false);
+        assert_eq!(result, " ");
+    }
+
+    #[test]
+    fn test_mask_value_hidden() {
+        let result = mask_value("sensitive_password", false);
+        assert_eq!(result, "********");
+    }
+
+    #[test]
+    fn test_mask_value_shown() {
+        let result = mask_value("some_value", true);
+        assert_eq!(result, "some_value");
+    }
+
+    #[test]
+    fn test_mask_empty_value() {
+        let result = mask_value("", false);
+        assert_eq!(result, "");
+    }
+}
diff --git a/src/utils/mod.rs b/src/utils/mod.rs
index 7dc3a09..c317eb8 100644
--- a/src/utils/mod.rs
+++ b/src/utils/mod.rs
@@ -1,2 +1,6 @@
 pub mod colors;
 pub mod paths;
+
+// Re-export commonly used functions for convenience
+pub use colors::{colorize_environment, format_default_marker, mask_value};
+pub use paths::{find_project_root, get_config_path};
diff --git a/src/utils/paths.rs b/src/utils/paths.rs
index 75ab604..afcf948 100644
--- a/src/utils/paths.rs
+++ b/src/utils/paths.rs
@@ -1 +1,122 @@
-// paths.rs module
+use anyhow::Result;
+use std::path::{Path, PathBuf};
+
+/// Find the project root directory by searching for .stand.toml or .stand/ directory
+pub fn find_project_root() -> Result<PathBuf> {
+    let current_dir = std::env::current_dir()?;
+    let mut dir = current_dir.as_path();
+
+    loop {
+        // Check for .stand.toml file
+        if dir.join(".stand.toml").exists() {
+            return Ok(dir.to_path_buf());
+        }
+
+        // Check for .stand directory (legacy)
+        if dir.join(".stand").exists() && dir.join(".stand").is_dir() {
+            return Ok(dir.to_path_buf());
+        }
+
+        // Move to parent directory
+        match dir.parent() {
+            Some(parent) => dir = parent,
+            None => break,
+        }
+    }
+
+    anyhow::bail!("Stand project not found. Run 'stand init' to initialize.")
+}
+
+/// Get the path to the configuration file (.stand.toml)
+pub fn get_config_path(project_root: &Path) -> PathBuf {
+    project_root.join(".stand.toml")
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::fs;
+    use tempfile::TempDir;
+
+    #[test]
+    fn test_find_project_root_with_stand_toml() {
+        let temp_dir = TempDir::new().unwrap();
+        let config_file = temp_dir.path().join(".stand.toml");
+        fs::write(&config_file, "version = \"2.0\"").unwrap();
+
+        // Change to temp directory to simulate being in project
+        let original_dir = std::env::current_dir().unwrap();
+        std::env::set_current_dir(temp_dir.path()).unwrap();
+
+        let result = find_project_root();
+        std::env::set_current_dir(original_dir).unwrap();
+
+        assert!(result.is_ok());
+        assert_eq!(
+            result.unwrap().canonicalize().unwrap(),
+            temp_dir.path().canonicalize().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_find_project_root_with_stand_dir() {
+        let temp_dir = TempDir::new().unwrap();
+        let stand_dir = temp_dir.path().join(".stand");
+        fs::create_dir(&stand_dir).unwrap();
+
+        let original_dir = std::env::current_dir().unwrap();
+        std::env::set_current_dir(temp_dir.path()).unwrap();
+
+        let result = find_project_root();
+        std::env::set_current_dir(original_dir).unwrap();
+
+        assert!(result.is_ok());
+        assert_eq!(
+            result.unwrap().canonicalize().unwrap(),
+            temp_dir.path().canonicalize().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_find_project_root_not_found() {
+        let temp_dir = TempDir::new().unwrap();
+
+        let original_dir = std::env::current_dir().unwrap();
+        std::env::set_current_dir(temp_dir.path()).unwrap();
+
+        let result = find_project_root();
+        std::env::set_current_dir(original_dir).unwrap();
+
+        assert!(result.is_err());
+    }
+
+    #[test]
+    fn test_find_project_root_in_subdirectory() {
+        let temp_dir = TempDir::new().unwrap();
+        let config_file = temp_dir.path().join(".stand.toml");
+        fs::write(&config_file, "version = \"2.0\"").unwrap();
+
+        let sub_dir = temp_dir.path().join("subdir");
+        fs::create_dir(&sub_dir).unwrap();
+
+        let original_dir = std::env::current_dir().unwrap();
+        std::env::set_current_dir(&sub_dir).unwrap();
+
+        let result = find_project_root();
+        std::env::set_current_dir(original_dir).unwrap();
+
+        assert!(result.is_ok());
+        assert_eq!(
+            result.unwrap().canonicalize().unwrap(),
+            temp_dir.path().canonicalize().unwrap()
+        );
+    }
+
+    #[test]
+    fn test_get_config_path() {
+        let project_root = Path::new("/some/project");
+        let config_path = get_config_path(project_root);
+
+        assert_eq!(config_path, project_root.join(".stand.toml"));
+    }
+}
